#pragma kernel CSMain

struct Vert
{
    float4 position;
    float2 uv;
};

struct Voxel
{
    float3 position;
    float value;
};

int _Size;
int _Size2;
float _Isolevel;

static int vertexIndex = 0;
static int directionSwapper = 0;
static float3 vertexList[12];

StructuredBuffer<int> _TriangleConnectionTable;
StructuredBuffer<int> _CubeEdgeFlags;
StructuredBuffer<Voxel> _Voxels;

RWStructuredBuffer<Vert> _Vertices;
RWStructuredBuffer<int> _Triangles;

static int resolutions[8] =
{
    1, 2, 8, 4, 16, 32, 128, 64
};

static float4 vertPoint[12] =
{
    float4(1, 0, 0, 1),
    float4(3, 1, 1, 3),
    float4(3, 2, 2, 3),
    float4(2, 0, 0, 2),
    float4(5, 4, 4, 5),
    float4(7, 5, 5, 7),
    float4(7, 6, 6, 7),
    float4(6, 4, 4, 6),
    float4(4, 0, 0, 4),
    float4(5, 1, 1, 5),
    float4(7, 3, 3, 7),
    float4(6, 2, 2, 6)
};

void GetPoints(int x, int y, int z, out float points[8])
{
    points[0] = x + _Size * y + _Size2 * z;
    points[1] = points[0] + 1;
    points[2] = points[0] + _Size;
    points[3] = points[2] + 1;
    points[4] = points[0] + _Size2;
    points[5] = points[1] + _Size2;
    points[6] = points[2] + _Size2;
    points[7] = points[3] + _Size2;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Index of base points, and also adjacent points on cube.
    float basePoints[8];
    GetPoints(id.x, id.y, id.z, basePoints);

    // Store scalars corresponding to vertices.
    float storedScalars[8];
    for (int i = 0; i < 8; ++i)
    {
        storedScalars[i] = _Voxels[(int)basePoints[i]].value;
    }

    // Initialize cube index.
    int cubeIndex = 0;

    // First part of the algorithm uses a table which maps the vertices under the isosurface to the
    // intersecting edges. An 8 bit index is formed where each bit corresponds to a vertex.
    for (int j = 0; j < 8; ++j)
    {
        cubeIndex |= storedScalars[j] < _Isolevel ? resolutions[j] : 0;
    }

    // Find the edges that are intersecting with the surface
    int bits = _CubeEdgeFlags[cubeIndex];

    // If bits are equal to zero, there are no connections
    if (bits == 0)
    {
        return;
    }

    float alpha = 0.5f;
    int resValue = 1;

    for (int index = 0; index < 12; ++index)
    {
        if ((bits & resValue) != 0)
        {
            alpha = (_Isolevel - storedScalars[(int)vertPoint[index].y]) / (storedScalars[(int)vertPoint[index].x] - storedScalars[(int)vertPoint[index].y]);
            vertexList[index] = lerp(_Voxels[(int)basePoints[(int)vertPoint[index].z]].position, _Voxels[(int)basePoints[(int)vertPoint[index].w]].position, alpha);
        }

        resValue = resValue * 2;
    }

    cubeIndex <<= 4;

    int idx = id.x + id.y * _Size + id.z * _Size * _Size;

    int counter = 0;
    while (_TriangleConnectionTable[cubeIndex + i] != -1)
    {
        int index1 = _TriangleConnectionTable[cubeIndex + counter];
        int index2 = _TriangleConnectionTable[cubeIndex + counter + 1];
        int index3 = _TriangleConnectionTable[cubeIndex + counter + 2];

        _Vertices[idx * 15 + (3 * counter + 0)].position = float4(vertexList[index1], 1.0f);
        _Vertices[idx * 15 + (3 * counter + 1)].position = float4(vertexList[index2], 1.0f);
        _Vertices[idx * 15 + (3 * counter + 2)].position = float4(vertexList[index3], 1.0f);

        _Triangles[idx * 15 + (3 * counter + 0)] = vertexIndex;
        _Triangles[idx * 15 + (3 * counter + 1)] = vertexIndex + 1;
        _Triangles[idx * 15 + (3 * counter + 2)] = vertexIndex + 2;

        directionSwapper = 1 - directionSwapper;

        if (directionSwapper == 0)
        {
            _Vertices[idx * 15 + (3 * counter + 0)].uv = float2(0, 0);
            _Vertices[idx * 15 + (3 * counter + 1)].uv = float2(0, 1);
            _Vertices[idx * 15 + (3 * counter + 2)].uv = float2(1, 1);
        }
        else
        {
            _Vertices[idx * 15 + (3 * counter + 0)].uv = float2(1, 0);
            _Vertices[idx * 15 + (3 * counter + 1)].uv = float2(0, 0);
            _Vertices[idx * 15 + (3 * counter + 2)].uv = float2(1, 1);
        }

        vertexIndex += 3;
        counter += 3;
    }
}
